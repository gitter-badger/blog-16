---
title: Binary Search Implementation
date: 2016-07-28 12:01:20
tags: ProgrammingContests
---

C++ STL을 쓴다면 lower_bound나 upper_bound 함수를 통해 이분 탐색이 가능하나 vector, set 컨테이너나 혹은 배열을 쓰지 않을 경우 직접 이분 탐색을 구현하여야 하는 경우가 있다. 

## 정수형 범위에서 이분 탐색

아래의 코드는 필자가 선호하는 형태이다. 코드 이해를 돕기 위해 아래와 같은 상황을 설정하자. 상세한 제약은 생략하였다.
> 새로 개발한 스마트폰의 강도를 실험하기 위해 N층의 빌딩에서 스마트폰을 떨어뜨려 몇 층에서부터 깨지는지를 확인하고 싶다. 한 번 떨어뜨린 스마트폰은 충격을 받아 약해졌을 수 있기 때문에 다시 쓰지 않는다. 스마트폰이 빌딩 층 수만큼 있지는 않기 때문에 이분 탐색을 하려고 한다.

```cpp
int a = 1, b = N;
while (a <= b) {
    int mid = (a + b) / 2;
    bool isPhoneBroken = test(mid);
    if (isPhoneBroken) {
        b = mid - 1;
    } else {
        a = mid + 1;    
    }
}
```

위의 형태는 어디까지나 필자가 선호하는 형태이고 다른 형태가 당연히 존재할 수 있다.

초기 a, b의 상태와 반복문의 진리식을 보자.

```cpp
int a = 1, b = N;
while (a <= b) { ... }
```

> a <= k && k <= b를 만족하는 k는 아직 모르는 구간 이다. 

> k < a || b < k를 만족하는 k는 더 이상 탐색이 필요하지 않은 구간이다.

> -----[안깨짐]-----|a-----[모름]-----b|-----[깨짐]-----

1층에서 떨어뜨렸는데 깨질 수도 있고, N층에서 떨어뜨렸는데 안깨질 수도 있는 것이다. a <= b 조건이 참이라는 것은, 내가 모르는 구간이 존재한다는 의미이다. 탐색을 통해 a = 3이 되고, b = 3이 되었다면, 1~2층에서는 안깨지고, 4~N층에서는 깨지고, 3층에서는 모른다는 의미이다.

while 문을 탈출했다면 a > b 일 것이다. 위의 제시된 구현을 따른다면 a - b == 1 인 관계일 것이다.

> -----[안깨짐]-----b|a-----[깨짐]-----

이제 문제의 요구 따라 답을 반환하면 된다. 안깨지는 가장 높은 층을 요구하면 b (혹은 a-1)를 반환하면 되고, 깨지는 가장 낮은 층을 요구하면 a (혹은 b+1)를 반환하면 된다. 단, 문제 제약에 따라 탐색할 필요가 없는 구간에 대한 답 출력에 주의해야하는 경우도 있을 수 있다. (예를 들어, 빌딩의 최고층인 N층에서 깨지지 않았다고 N+1층에서 깨진다고 출력할 수 있을까?)

## 실수형 범위에서 탐색

만약 빌딩 층 수가 아니라 미터를 쓴다면 어떨까? a, b가 실수형이라면, 보통 문제의 제약에서 오차 범위가 주어진다. 위의 a, b 관계를 생각하면서 아래 코드를 읽어보고, 답을 어떻게 출력할 수 있을지는 스스로 생각해보는 것으로 포스팅을 마친다.

```cpp
double a = 0, b = N;
while (b - a > ERR_BOUND) {
    double mid = (a + b) / 2;
    bool isPhoneBroken = test(mid);
    if (isPhoneBroken) {
        b = mid;
    } else {
        a = mid;    
    }
}
```


